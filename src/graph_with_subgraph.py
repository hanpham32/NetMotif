import networkx as nx
import os
from io import StringIO
import streamlit as st
import streamlit.components.v1 as components
from pyvis.network import Network
import pandas as pd
from src.graph_utils import Graph
from src.subgraph import Subgraph
from src.esu import ESU
from src.graph_types import GraphType
import src.label as lb
import time

class GraphWithSubgraph(Graph):
    def __init__(self, graph_type, input, motif_size):
        # simple list of all subgraphs generated by ESU algorithm
        self.subgraph_list: list[Subgraph] = []
        # dictionary of subgraph enumeration (Subgraph -> #)
        self.subgraph_list_enumerated: dict = {}
        # number of nodes in subgraphs
        self.motif_size: int = motif_size
        # esu object for esu algorithm
        self.esu = None
        # instantiation of Graph object
        super().__init__(graph_type, input)
        # remove self loops
        self.G.remove_edges_from(nx.selfloop_edges(self.G))

        # creating Subgraph list and dict
        start_time = time.time()
        self.subgraph_list = self.weakly_connected_components_of_size_k(self.graph_type, self.G, motif_size)
        #self.runESU(motif_size, graph_type)
        # name and enumerate list of subgraphs
        self.enumerate_subgraphs()
        end_time = time.time()
        st.write(f"Time to run ESU and enumerate subgraphs: {end_time - start_time:.2f} seconds")

    def weakly_connected_components_of_size_k(self, graph_type, G, k):
        # List to store components of size k
        components_of_size_k = []

        # Set to keep track of visited nodes
        visited = set()

        # Helper function to perform DFS
        def dfs(node, component):
            stack = [node]
            while stack:
                current = stack.pop()
                if current not in visited:
                    visited.add(current)
                    component.add(current)
                    # Add all unvisited neighbors (in undirected graph)
                    for neighbor in nx.all_neighbors(G, current):
                        if neighbor not in visited:
                            stack.append(neighbor)

        # Iterate over all nodes in the graph
        for node in G.nodes():
            if node not in visited:
                # Start a DFS for this unvisited node
                component = set()
                dfs(node, component)

                # If the component has the desired size, add it to the result
                if len(component) == k:
                    components_of_size_k.append(component)

        #labeling subgraphs
        progress_text = "Labelg algorithm in progress. Please wait."
        my_bar = st.progress(0, text=progress_text)
        label_conversion_map: dict = {} #d6->g6
        numberOfConversions = 0
        subgraph_list = []
        for i, component in enumerate(components_of_size_k):
            nxgraph = G.subgraph(component)
            sub = Subgraph(graph_type=graph_type,input=nxgraph)
            d6 = lb.get_basic_graph_label(sub.G, graph_type)
            if(d6 not in label_conversion_map):
                numberOfConversions += 1
                g6 = lb.get_graph_label(sub.G, graph_type) #expensive operation, minimize use!
                label_conversion_map[d6] = g6
                sub.set_label(g6)
            else:
                sub.set_label(label_conversion_map[d6])
            subgraph_list.append(sub)
            my_bar.progress(i/len(components_of_size_k), text=progress_text)
        my_bar.empty()
        st.write("number of labelg calls: " + str(numberOfConversions))
        return subgraph_list

    def runESU(self, motif_size, graph_type):
        # produce list of subgraphs
        self.esu = ESU(self.G, motif_size, graph_type)
        self.subgraph_list = self.esu.get_subgraph_list()

    def enumerate_subgraphs(self):
        for subgraph in self.subgraph_list:
            if subgraph not in self.subgraph_list_enumerated:
                self.subgraph_list_enumerated[subgraph] = 1
            else:
                self.subgraph_list_enumerated[subgraph] += 1

    def draw_subgraph(self):
        output_dir = "drawings/subgraphs"  # output directory
        # make sure output folder for the drawings exists
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        for i, subgraph in enumerate(self.subgraph_list_enumerated.keys()):
            st.markdown(
                f"### Subgraph {subgraph.get_label()}"
            )
            subgraph.draw_graph("nx_subgraph_{i}.html")
        return

    def get_graph_properties(self):
        simple_properties = super().get_graph_properties()
        if simple_properties is None:
            return None

        simple_properties.update({
            "Number of subgraphs": len(self.subgraph_list),
        })

        return simple_properties

    def generate_nemo_count(self):
        # do nothing
        return

    # @st.cache_data
    def generate_subgraph_profile(self):
        output_dir = "out"
        subgraph_profile_output = os.path.join(output_dir, "subgraph_profile.txt")

        # Ensure output folder exists
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # label-node count dictionary
        nodes_dictionary = {}

        # iterate over subgraphs
        for subgraph in self.subgraph_list:
            label = subgraph.get_label()
            # if label not accounted for
            if label not in nodes_dictionary:
                # fill in all node count as 0 for label
                nodes_dictionary[label] = {}
                for node in self.G:
                    nodes_dictionary[label][node] = 0
            # for every node in the subgraph add 1 to its label-node count
            for node in subgraph.G.nodes:
                nodes_dictionary[label][node] += 1

        # Write into file
        with open(subgraph_profile_output, "w") as file:
            top_row = f"{'Nodes':<10}"  # top row for graph labels
            for key in nodes_dictionary:
                top_row += f"{key.strip():<10}"  # strip new line from label
            top_row += "\n"  # make space for the nodes and their count
            file.write(top_row)
            # each nodes count in its associated graph
            for node in self.G:
                line = f"{node:<10}"
                for key in nodes_dictionary:
                    line += f"{nodes_dictionary[key][node]:<10}"
                line += "\n"
                file.writelines(line)

        # Display download button for file
        with open(subgraph_profile_output, "r") as file:
            return st.download_button(
                label="Download subgraph profile",
                data=file,
                file_name="subgraph_profile.txt",
            )

    # @st.cache_data
    def generate_subgraph_collection(self):
        output_dir = "out"
        subgraph_collection_output = os.path.join(output_dir, "subgraph_collection.txt")

        # Ensure output folder exists
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # Write into file
        with open(subgraph_collection_output, "w") as file:
            for subgraph in self.subgraph_list:
                nodes = subgraph.G.nodes()
                line = ""
                line += subgraph.get_label() + "[" + ", ".join([str(x) for x in nodes]) + "] \n"
                file.write(line)

        # Display download button for file
        with open(subgraph_collection_output, "r") as file:
            return st.download_button(
                label="Download subgraph collection",
                data=file,
                file_name="subgraph_collection.txt",
            )